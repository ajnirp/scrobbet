#!/usr/bin/env python3
# -*- coding: UTF-8 -*-

"""
Scrobbet, the unofficial CLI scrobbler for Last.fm.

Usage:
  scrobbet (-h | --help)
  scrobbet --version
  scrobbet --authorize
  scrobbet (-s | --scrobble) [--title=<name>] [--artist=<name>] [--album=<name>] [--directory=<name>]

Options:
  -h --help           Show this screen.
  --version           Show version.
  --authorize         Authorize Scrobbet to access your account on last.fm
  -s --scrobble       Scrobble all music tracks in the current directory to last.fm
  --title=<name>      Scrobble only tracks with title 'name'
  --artist=<name>     Scrobble only tracks by artist 'name'
  --album=<name>      Scrobble only tracks from the album 'name'
  --directory=<name>  Scrobble only tracks in directory 'name' [default: .]
"""

import requests # making HTTP requests
import taglib # reading IDv3 tags
import os # listing contents of a dir
import magic # inferring MIME-types
import docopt # CLI argument parsing
import signal, sys # intercepting SIGINT
import webbrowser # user authorization
import tty, termios # yes-no-prompt
from time import time # getting the current time
from hashlib import md5 # 32-char hex digest of a string
from bs4 import BeautifulSoup as bs # parsing XML responses from Last.fm
from secrets import * # api key, secret and session key
from math import log10, ceil # get maximum number of digits required to write a tracknumber

SCROBBLE_ROOT = 'http://ws.audioscrobbler.com/2.0/'
ATTRIBUTE_LIST = ['artist', 'title', 'album']

supported_mime_types = set([
	'audio/mpeg',
	'audio/mp4',
	'audio/m4a',
	'audio/ogg',
	'audio/flac',
	'audio/wav',
	'audio/aiff'
])

# check if user is connected to the internet
def check_connectivity(timeout=5):
	try:
		# hit example.com
		_ = requests.get('http://93.184.216.119', timeout=timeout)
		return True
	except requests.ConnectionError:
		print("You're not connected to the internet!")

# get authentication token in order to get user authorization
def get_token():
	params = {
		'method': 'auth.getToken', 
		'api_key': API_KEY
	}
	params['api_sig'] = construct_api_sig(params)
	token_response = requests.post(SCROBBLE_ROOT, params=params)
	parsed_response = bs(token_response.text)
	return parsed_response.token.string

# request session key from last.fm
def get_session(token):
	params = {
		'method': 'auth.getSession',
		'api_key': API_KEY,
		'token': get_token()
	}
	params['api_sig'] = construct_api_sig(params)
	session_response = requests.post(SCROBBLE_ROOT, params=params)
	parsed_response = bs(session_response.text)
	return parsed_response.key.string

# get authorization from user to scrobble to their account
def request_authorization(token):
	print('Scrobbet needs your permission to scrobble to your account. Opening a browser window...')
	url = 'http://www.last.fm/api/auth/?api_key=' + API_KEY + '&token=' + token
	webbrowser.open_new(url)
	print("Please select 'Authorize'!")

# set up a web service session
def fetch_web_service_session():
	pass #todo

# construct API signature from the params dict
def construct_api_sig(params):
	api_sig_string = ''.join(key + params[key] for key in sorted(params.keys())) + SECRET
	return md5(api_sig_string.encode('utf-8')).hexdigest()

# build the final params dict from the track metadata
def construct_params(tags, timestamp):
	# read in the tags
	params = {
		'method': 'track.scrobble',
		'api_key': API_KEY,
		'sk': SESSION_KEY,
		'timestamp': timestamp,
		'artist': tags['ARTIST'][0],
		'track': tags['TITLE'][0],
		'album': tags['ALBUM'][0]
	}
	params['api_sig'] = construct_api_sig(params)
	return params

# get IDv3 tags for a music file
def get_tags(filename):
	return taglib.File(filename).tags

# set up the params and scrobble!
def make_scrobble_request(tags, timestamp):
	params = construct_params(tags, timestamp)
	scrobble_response = requests.post(SCROBBLE_ROOT, params=params)
	parsed_response = bs(scrobble_response.text)
	return parsed_response

# is 'filename' an audio file?
def is_audio_file(filename):
	mime_type = magic.from_file(filename, mime=True).decode('utf-8')
	return mime_type in supported_mime_types

# this function returns True if 'tags' matches the user-specified constraints, 'False' otherwise
def do_tags_match_args(tags, arguments):
	# print(tags, arguments)
	return all(arguments['--' + attribute] is None # user specified no constraints
		       or arguments['--' + attribute] in tags[attribute.upper()] # user did specify constraints, check 'em
		       for attribute in ATTRIBUTE_LIST)

# return a list of all the audio files in 'directory' sorted by tracknumber and
# satisfying the user-specified constraints, like artist and album
def grab_sorted_music_files(arguments):
	directory = arguments['--directory']
	musicfiles = [
		filename for filename in os.listdir(directory)
		         if os.path.isfile(filename) and is_audio_file(filename)
	]
	# zip the files together with their respective tags
	files_tags_zipped = [(f, taglib.File(f).tags, taglib.File(f).length) for f in musicfiles]
	# filter out files not satisfying the user constraints
	files_tags_zipped = filter(lambda x: do_tags_match_args(x[1], arguments), files_tags_zipped)
	# sort the files by track number
	files_tags_zipped = sorted(files_tags_zipped, key=lambda x: int(x[1]['TRACKNUMBER'][0].split('/')[0]))
	return files_tags_zipped

# yes/no prompt
def confirm_scrobbles():
	print('Do you want to scrobble these tracks? [y/N]')
	fd = sys.stdin.fileno()
	old_settings = termios.tcgetattr(fd)
	try:
		tty.setraw(sys.stdin.fileno())
		ch = sys.stdin.read(1)
	finally:
		termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
	print(ch)
	return ch.lower() in {'y'}

# tell the user which tracks will be scrobbled
def announce_tracks(files_tags_zipped):
	if list(files_tags_zipped) == []:
		print("Couldn't find any tracks for these parameters")
		print("Exiting...")
		exit(1)
	print('The following tracks will be scrobbled:')
	num_tracks = len(list(files_tags_zipped))
	for _, tags, _ in files_tags_zipped:
		artist = tags['ARTIST'][0]
		title = tags['TITLE'][0]
		album = tags['ALBUM'][0]
		tracknumber = str(tags['TRACKNUMBER'][0].split('/')[0])
		print('\t', tracknumber.zfill(ceil(log10(num_tracks))), artist, '-', title, '-', album)
	if confirm_scrobbles():
		print('Scrobbling...')
		return
	else:
		print('Exiting...')
		exit(1)

# do everything, lel
def scrobble(arguments):
	# signal.signal(signal.SIGINT, sigint_handler)
	tracks_to_scrobble = grab_sorted_music_files(arguments)
	announce_tracks(tracks_to_scrobble)
	timestamp = int(time())
	for track, tags, length in reversed(tracks_to_scrobble):
		title = tags['TITLE'][0]
		response = make_scrobble_request(tags, str(timestamp))
		timestamp = timestamp - length
		lfm_status = response.lfm['status']
		if lfm_status == 'ok':
			print('\t', title)

# return session key if already stored else make dotfile and return False
def check_dotfile():
	if not os.path.exists('~/config'):
		os.makedirs('~/config')
	if not os.path.isfile('~/config/.scrobbetsession'):
		open('~/config/.scrobbetsession', 'w').close()
		return False
	file = open('~/config/.scrobbetsession', 'r')
	sk = file.read(32)
	file.close()
	if len(sk) == 0:
		return False
	return sk

# # check if authorization has been done
# def check_authorization():
# 	sk = check_dotfile()
#	if sk == False
#		need_to_auth
# 

if __name__ == "__main__":
	arguments = docopt.docopt(__doc__, version='Scrobbet 0.1')
	# if arguments['--authorize']:
	# 	check_authorization()
	if arguments['--scrobble']:
		print("Searching tracks in '" + arguments['--directory'] + "' matching:")
		for attribute in ATTRIBUTE_LIST:
			attr_val = arguments['--' + attribute]
			if attr_val: print('\t' + attribute.title() + ':', attr_val)
			else: print('\tAny', attribute)
		scrobble(arguments)